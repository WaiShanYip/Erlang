-module(classwork).
-compile(export_all).

                        %%Class 2

%Takes 3 integers and returns the maximum of the 3.
maxThree(X, Y, Z) -> max(max(X, Y), Z).

%Takes 3 integer and returns an integer which counts how many of its 3
%arguments are equal.
howManyEqual(X, X, X) -> 3;
howManyEqual(_X, _Y, _X) -> 2;
howManyEqual(X, X, _Y) -> 2;
howManyEqual(_Y, X, X) -> 2;
howManyEqual(_, _, _) -> 0.

%Gives the perimeter of a circle and a rectangle.
perimeter({circle, R}) -> (math: pi() *2) * R;
perimeter({rectangle, H, W}) -> H + H + W + W.

%Area and perimeter of a triangle.
trianglePerimeter({triangle, A, B, C}) -> A + B + C.
triangleArea({triangle, A, B, C}) -> S = (A + B + C)/2,
    math: sqrt(S*(S-A) * (S-B) * (S-C)).

%fib is generated by adding the previous 2 values to give the next.
fib(0) -> 0;
fib(1) -> 1;
fib(N) when N>1 -> fib(N-2) + fib(N-1).

%fib2 so that fib2(N) is the Nth and N+1th fibonacci numbers paired 
%together.
fib2(0) -> {0, 1};
fib2(N) when N>0 -> {A,B} = fib2(N-1), {B, A+B}.

%sum_to takes an integer argument N and gives it as a result.
sum_to(0) -> 0;
sum_to(N) when N>0 -> N + sum_to(N-1).

%sum_range takes 2 integer arguments M and N and returns the sum M + M+1...
sum_range(M, N) when N < M -> 0;
sum_range(M, N) -> M + sum_range(M+1, N).

%Tells you the maximum number of pieces into which you can cut a piece
%of paper with N cuts
pieces(0) -> 1;
pieces(1) -> 2;
pieces(2) -> 4;
pieces(N) -> N + pieces(N-1).

%Add 2 fractions together.
%Multiply 2 fractions together.
%Given 2 fractions, decides whether the 1st fraction is greater than
%the second.
addFraction({A, B}, {C, D}) when B == D -> ({A + C, B});
addFraction({A, B}, {C, D}) -> ({A*D + C*B, B*D}).

multiFraction({A, B}, {C, D}) -> ({A*C, B*D}).

compFraction({_A, B}, {C, D}) when B>D -> {C, D};
compFraction({A, B}, {_C, D}) when D>B -> {A, B};
compFraction({A, B}, {C, D}) when B==D andalso A > C -> {A, B};
compFraction({A, B}, {_C, _D}) -> {A, B}.


                        %Class 3

%Multiplies together the number in the list and returns 1 in the case
%of an empty list.
mult([]) -> 1;
mult([X| XS]) -> X * mult(XS).

%Gives the maximum of the number and 0 in the case of an empty list.
maximum([]) -> 0;
maximum([X]) -> X;
maximum([X| XS]) when XS > X -> maximum(XS).

%Finds out whether a given number appears in the list.
member(_X,[])-> false;
member(X, [X| _XS]) -> true;
member(X, [_Y| YS]) -> member(X, YS).

%The first argument selects only numbers greater than N in the list.
greater(_N, []) ->[];
greater(N, [X| XS]) when N<X -> [X| greater(N, XS)];
greater(N, [_X| XS]) -> greater(N, XS).

%The first argument selects the first number greater than N in the list.
greater_f(_N, []) -> [];
greater_f(N, [X| _XS]) when N<X -> X;
greater_f(N, [_X| XS]) -> greater_f(N, XS).

%Reverses a list of numbers.
reverse([]) -> [];
reverse([X| XS]) -> reverse(XS) ++ [X].

%Joins together 2 lists
append([], Ys) -> Ys;
append([X| XS], Ys) -> [X| append(XS, Ys)].

%Takes 2 integers and returns the Nth element of the list XS
index(0, [X| _XS]) -> X;
index(N, [_X| XS]) when N>0 -> index(N-1, XS).

%Build lists of consecutive numbers
build(N, M) when N>M -> [];
build(N, M) -> [N| build(N+1, M)].

%Merges 2 ordered lists into one single ordered list
merge([], [Y|YS]) -> [Y| YS];
merge([X|XS], []) -> [X| XS];
merge([X| XS], [Y| YS]) when Y>X -> [X| merge(XS,[Y| YS])];
merge([X| XS], [Y| YS]) when X>Y -> [Y| merge(YS, [X|XS])].

%Splits the list and then orders each half and merges them together.
mergeSort([]) -> [];
mergeSort([X]) -> [X];
mergeSort(Xs) -> 
    {Ys, Zs} = lists:split(length(Xs) div 2, Xs),
Sorted_YS = mergeSort(Ys),
Sorted_ZS = mergeSort(Zs),
merge(Sorted_YS, Sorted_ZS).


                            %Class 5
%Counts the number of occurences of an element in an arbitrary tree.
countAT(_N, leaf) -> 0;
countAT(N, {node, N, T1, T2}) -> 1 + countAT(N, T1) + countAT(N, T2);
countAT(N, {node, _V, T1, T2}) -> countAT(N, T1) + countAT(N, T2).

%Counts the number of occurences of an element in an ordered tree.
countOT(_N, leaf) -> 0;
countOT(N, {node, N, T1, T2}) -> 1 + countOT(N, T1) + countOT(N, T2);
countOT(N, {node, V, T1, _T2}) when N < V -> countOT(N, T1);
countOT(N, {node, V, _T1, T2}) when N > V -> countOT(N, T2).

%Turns a list into an ordered tree.
insert(X, leaf) -> {node, X, leaf, leaf};
insert(X, {node, V, T1, T2}) when X =< V -> {node, X,insert (X, T1), T2};
insert(X, {node, V, T1, T2}) when X > V -> {node, X, T1, insert(X, T2)}.

tree([]) -> leaf;
tree([X| XS]) -> insert(X, tree(XS)).



















